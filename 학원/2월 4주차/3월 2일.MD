# Review
- 예외처리 : 잘못 사용했거나, 잘못된 코딩으로 인해 실행 중 발생한 오류

#### public?
- 접근지정자중 하나
- Class 앞에 public을 붙여주면, 또는 변수앞에 public을 붙여주면 프로젝트 안에서 다른 package에서도 호출하여 사용할 수 있게 된다.
- public, protected, default, private의 종류가 있다.

## 오늘의 학습목표
- 학습내용 :
1) 클래스 안에 변수, 생성자, 메소드의 종류와 특징을 이해
2) 오버라이딩의 개념을 이해
3) this, this()의 차이를 이해할 수 있

- 공지사항 : 포트폴리오

------------------------------------------------------------------------------------------------------------

## 새로 알게된 것
- return d1.int 가 안되는 이유

반환 타입이 Data인데 d1.int를 하려면 int add(Data d1, Data d2) 이런식으로 해줘야함!!!

- this() 키워드는 메서드에서 다시 가져올때 제일 위에 하나만 가능하다!!! super


### 절차지향 vs 객체지향
- 절차지향 : 작업의 ***순서*** 표현, 작업을 함수로 작성한 함수들의 집함
- 객체지향 : 객체들간의 ***상호 작용***으로 표현, 클래스 혹은 개체들의 집합으로 프로그램 작성

### 문자열 다루는데 있어 알아야할 사항
```java
/*
			. 문자열을 다루는데 있어 알아야할 사항
			  - 문자열을 생성하는 방법은 두가지가 있다.
				.첫번째 : String str = new String("안녕");
				.두번째 : String str = "안녕";
				
			  - 스트링 리터럴: 자바 내부적으로 '리터럴 테이블'로 특별히 관리되는
			  		테이블이 JVM스트링 리터럴테이블이 존재한다.
			  		
			  		String a = "Hello"   a --- > Hello
			  		String b = "Java"    b --- > Java
			  		String c = "Hello"   c --- x (a의 것을 공유)
			  		
			  - 스트링 객체 : new String()
			  		. 힙메모리에 생성된다.
			  		String d = new String("Hello");  d ---> Hello
			  		String e = new String("Java")    e ---> Java
			  		String f = new String("Hello")   f ---> Hello
			  		
			  		
		
		*/
```

### 매개 변수 이용하기
```java
package step2_필드;

import java.util.Scanner;

class Score1 {
	
	
	int[] caculated(int[] score) {
		
		for(int i=0;i<score.length;i++) {
			score[i] += score[i] + 15;
		}
		return score;
	}
	
	
}


public class V3_매개변수Ex2 {


	public static void main(String[] args) {
		
		int[] stu = new int[3];
		Scanner sc = new Scanner(System.in);
		
		System.out.println("국어 점수 입력");
		stu[0] = sc.nextInt();
		System.out.println("영어 점수 입력");
		stu[1] = sc.nextInt();
		System.out.println("수학 점수 입력");
		stu[2] = sc.nextInt();
		
		Score1 cacul = new Score1();
		
		int[] score = cacul.caculated(stu);
		
		for(int value: score) {
			System.out.println(value);
		}
	}
}

```

### 메소드 객체전달에서 좋았던 예제
- 객체지향을 이해하기 좋았다
- return d1.int 가 안되는 이유
반환 타입이 Data인데 d1.int를 하려면 int add(Data d1, Data d2) 이런식으로 해줘야함!!!

```java
package step4_메소드;

class Data{
	int kor;
	int eng;
	
	Data add(Data d1, Data d2) {
//		d1.kor = d2.eng;
		
		d1.eng = d2.kor;
		
		System.out.println("d1.kor : " + d1.kor); // add(d2,d1) 으로하면 애초에 값이없으니 0 되는거고
		System.out.println("d2.eng : " + d2.eng); // 아래에서는 그냥 출력하게되니까 80 0이 나오는건
		
		// d1객체만 리턴한다...
		return d1; // 리턴값이 d1이니까 출력이 될수 없지
	}
}

public class m2_객체전달 {
	public static void main(String[] args) {
		
		// 1. 객체를 전달하려면... 객체가 준비가 되어야 한다.
		Data d1 = new Data();
		Data d2 = new Data();
		Data d3 = new Data();
		
		d1.kor = 70;
		d2.eng = 80;
		
		
		//2. 메소드에 매개변수로 객체를 전달한다.
		Data d4 = d3.add(d2,d1);   // eng 변수에 80을 넣고 , kor 변수에 70을 넣음) , 근데 위에서는 kor eng를 원하니 무시
		System.out.println("***********************");
		System.out.println(d4.eng);
		System.out.println(d4.kor);
	}
}
```

### this() 키워드는 신기하다
```java
package step3_생성자;

/*
	this vs this()
	
	this : 내 자신의 객체
	this() : 나의 생성자를 호출 , 오버로딩방식 호출, 첫줄에 작성해야 한다.
	super :
	super() : 
	

*/

class Sonata {
	
	// 생성자 - 기본생성자, 초기화, void를 사용하지 않고, return도 없다.
	Sonata() {}
	
	Sonata(int num) {
		System.out.println("자동차 도어 수는 " + num + "개 입니다.");
	}
	
	Sonata(String color) {
		System.out.println("자동차의 색상은" + color + "색 입니다.");
	}
	
	Sonata(int num, String option) {
		this(num); // 정수 하나짜리를 실행하고 다시 내려와서 아래꺼 실행
		System.out.println("옵션은 " + option + " 입니다.");
	}
	
}


public class C1_Constructor {
	public static void main(String[] args) {
		
		Sonata car1 = new Sonata();
//		Sonata car2 = new Sonata(2);
//		Sonata car3 = new Sonata("그린");
		Sonata car4 = new Sonata(4, "에어백");
		
		
		
	}
}

```
