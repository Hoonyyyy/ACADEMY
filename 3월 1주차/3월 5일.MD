### Review
객체배열
- 클래스를 저장할 수 있는 객체를 생성한다.
- 클래스의 객체를 생성한다.
- 배열속에 객체를 저장한다.
- 객체 배열을 필요로 하는 메소드에 객체배열을 인수로 해서 호출한다.
- 메소드에서 받아서 필요한 비즈니스 로직을 처리한다.

클래스 생성자에서 객체나 배열 초기화

static
- static은 객체 간에 공유되고,
- 클래스명. static변수/클래스명.static메소드로 직접 호출이 가능하다.
- static 클래스 속에는 밖에 선언된 static 필드/메소드만 호출 가능하다.
- static 클래스 속에서 멤버변수/멤버 메소드를 선언하여 생성할 수 있지만, static변수/static메소드를 선언하여 생성할 수 없다.


## 오늘의 학습목표
학습 내용
- 상속의 개념을 이해하고 구현할 수 있다.
- 상속관계에서 업캐스팅/다운캐스팅을 구현할 수 있다.
- 오버라이딩을 구현할 수 있다.
- 클래스 다이어그램을 작성할 수 있다.

공지사항
- 포트폴리오

--------------------------------------------------------------------------------

## 같은 파일에 클래스가 여러개일때 public은 1개여야함

### 상속(inheritance) 문법
- 단일 상속만 가능하다.
- 상속이 되면, 부모의 필드와 메소드를 자식이 자기 것처럼 접근할 수 있다.
- 생성자는 상속되지 않는다.
- 부몰르 Super라고 부른다. - super, super() 가 있다.
- 자식에서 객체를 생성하면, 부모의 기본 생성자를 찾으며 올라간다.
- 부모의 메소드는 자식이 재정의(Override)할 수도 있다.



상속에 관련해서 기본생성자가 왜 필요한지? 없으면 어떻게 구성해야 하는지 등을 알게 됨
```java
package step1_상속;

class A1 {
	int x;
	A1(int x) {
		this.x = x;
		System.out.println("생성자A");
	}
}

class B1 extends A1 {
//	int x;
//	B1() {}
	B1(int x) {
//		this.x = x;
		super(10);
		System.out.println("생성자B");
	}
}

class C1 extends B1 {
	C1(int x) {
		super(10);   // 막아두면 기본생성자를 찾아가기에 상속 주는곳에서 기본생성자를 만들어주거나 얘를 만들어줘야함
		System.out.println("생성자C");
	}
	
//	C1(int x) {
//		System.out.println("생성자C에 매개변수 1개");
//	}
	
	void print() {
		System.out.println("생성자 우선순위에 대한 학습");
	}
	
}

public class Inher3_생성자 {
	public static void main(String[] args) {
		
		A1 a1 = new A1(10);
		B1 b1 = new B1(10);
		
		C1 c = new C1(10); // 상속을 줄 부모 클래스에서 기본 메서드로 설정시 다 같이 나옴 그래서 매개변수를 넣어줘야 c값만 나옴
		
		
	}
}

```
